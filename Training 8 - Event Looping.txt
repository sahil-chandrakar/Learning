JavaScript Is Single-Threaded
----------
JavaScript runs one line at a time inside the Call Stack.
But it can still handle async tasks like:
setTimeout
fetch()
Promises
Event listeners

This is possible because of the Event Loop system.

Event Loop - Simple Meaning
----------
Event Loop decides what should run next when:
- synchronous code is running
- async tasks finish
- callbacks are waiting

Components of Event Loop
---------
1. Call Stack
Where synchronous code runs.

Example:
console.log("Mani");
console.log("Rajesh");

2. Web APIs (Browser Background)
Handles async operations like:
setTimeout
fetch
DOM events
These do not block the main thread.

Example:
setTimeout(() => console.log("Timeout"), 2000);
fetch("url");

3. Queues

Microtask Queue (High Priority)
Contains:-
Promises (then, catch)
async/await resolved tasks
Runs before macrotask.

Example:
Promise.resolve().then(() => console.log("Promise"));

Macrotask Queue (Low Priority)
Contains:
setTimeout
setInterval
UI events

Example:
setTimeout(() => console.log("Timer"));

How Event Loop Works
-----------

1. Run all synchronous code in the Call Stack.
2. Async tasks move to Web APIs.
3. When async task finishes:
   Promise -> Microtask Queue
   setTimeout -> Macrotask Queue
4. Event Loop checks if Call Stack is empty.
5. If empty:
   Microtask Queue runs first
   Macrotask Queue runs second

Example Code:
-----

	console.log("Mani");

	setTimeout(() => {
   		console.log("setTimeout");
	}, 2000);

	fetch("data")
   	.then(() => console.log("data"));

	console.log("Rajesh");

Execution Order:
Mani
Rajesh
data
setTimeout


